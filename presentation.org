#+TITLE: PUG Milan 13/02/2019

* PHPStan

If you don't use PHPStan in 2019, shame on you
- [[file:src/undefined_variable.php::echo%20$b;][Undefined variables]]
- [[file:src/undefined_classes.php::$foo%20=%20new%20Foo();][Undefined classes]]
- [[file:src/simple_types.php::needAnInteger(1);][Simple types]]
- [[file:src/union_types.php::needAnInteger($d);][Union types]]
- [[file:src/optional_types.php::needAnInteger(maybeReturnsAnInteger(true));][Optional types]]
- [[file:src/constant_types.php::echo%20$a%5B'd'%5D;][Constant types]]
- [[file:src/properties.php::$p->foo%20=%20"Something";][Properties]]
- [[file:callable_types.php::$callable(1);][Callable types]]
- [[file:src/generic_types.php::swap($b);][Generic types]]
- [[file:src/dependent_types.php::printf("This%20is%20a%20number%20%25d",%201,%20"bar");][Depentent types]]

* PHPStan: I had a problem (1)

It can be used as it is or it can be extended with custom rules

For a long time I had this problem with value objects or simple DTOs

How to implement them?

#+BEGIN_SRC php :eval never
class Amount
{
    /** @var int */
    private $cents;

    /** @var int */
    private $precision;

    /** @var string */
    private $currency;

    public function __construct(int $amount, string $currency, int $precision = 2)
    {
        $this->cents = $cents;
        $this->precision = $precision;
        $this->currency = $currency;
    }

    public function getCents(): int
    {
        return $this->cents;
    }

    // ... You got it
}
#+END_SRC

Tedious... I know that an IDE can generate it but...

* PHPStan: I had a problem (2)

Searching around... :-O

#+BEGIN_SRC php :eval never
class Amount {
    /** @var int */
    public $cents;

    /** @var int */
    public $precision;

    /** @var string */
    public $currency;

    public function __construct(int $cents, string $currency, int $precision = 2)
    {
        // ... You got it
    }
}
#+END_SRC

Forget information hiding, here there's nothing to hide, the worst
problem here is that value objects are immutable and here you cannot
prevent it.

* PHPStan: cool things

I want:
- Guaranteed immutability
- Dryness
- Type safety
- Usability

Enter [[file:src/Amount.php::final%20class%20Amount%20extends%20Precious][Precious]]

* PHPStan: cool things

PHPStan can be extended, every project/library can define their rule,
knowing the context you can be more clever in knowing what is right
and what is wrong.

When you include a library that defines some custom rules you can
include them using your [[file:phpstan.neon::parameters:][phpstan file]].

Example of Precious rules:
- A value object must be declared [[file:src/Amount.php::final%20class%20Amount%20extends%20Precious][final]], we have a [[file:vendor/gabrielelana/precious/src/PHPStan/Rule/PreciousClassMustBeFinalRule.php::public%20function%20processNode(Node%20$node,%20Scope%20$scope):%20array][rule]] for that
- All properties must be accessible
- All properties must be read only
- All properties must be typed
- Undefined properties must be reported

All of that is done with a [[file:vendor/gabrielelana/precious/src/PHPStan/Reflection/PreciousPropertiesClassReflectionExtension.php::class%20PreciousPropertiesClassReflectionExtension%20implements%20PropertiesClassReflectionExtension,%20BrokerAwareClassReflectionExtension][property class reflection extension]]
